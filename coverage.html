
<!DOCTYPE html>
<!--suppress Annotator -->
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kdimtriCP/gh-inspector/cmd/root.go (30.0%)</option>
				
				<option value="file1">github.com/kdimtriCP/gh-inspector/cmd/score.go (9.5%)</option>
				
				<option value="file2">github.com/kdimtriCP/gh-inspector/internal/cache/cache.go (90.0%)</option>
				
				<option value="file3">github.com/kdimtriCP/gh-inspector/internal/cache/sqlite.go (75.5%)</option>
				
				<option value="file4">github.com/kdimtriCP/gh-inspector/internal/formatter/csv.go (83.3%)</option>
				
				<option value="file5">github.com/kdimtriCP/gh-inspector/internal/formatter/factory.go (100.0%)</option>
				
				<option value="file6">github.com/kdimtriCP/gh-inspector/internal/formatter/json.go (100.0%)</option>
				
				<option value="file7">github.com/kdimtriCP/gh-inspector/internal/formatter/table.go (100.0%)</option>
				
				<option value="file8">github.com/kdimtriCP/gh-inspector/internal/formatter/types.go (96.4%)</option>
				
				<option value="file9">github.com/kdimtriCP/gh-inspector/internal/github/analyzer.go (0.0%)</option>
				
				<option value="file10">github.com/kdimtriCP/gh-inspector/internal/github/client.go (100.0%)</option>
				
				<option value="file11">github.com/kdimtriCP/gh-inspector/internal/github/metrics.go (0.0%)</option>
				
				<option value="file12">github.com/kdimtriCP/gh-inspector/internal/metrics/repository.go (100.0%)</option>
				
				<option value="file13">github.com/kdimtriCP/gh-inspector/internal/mock/mock_cache/mock_types.go (0.0%)</option>
				
				<option value="file14">github.com/kdimtriCP/gh-inspector/internal/mock/mock_formatter/mock_formatter.go (0.0%)</option>
				
				<option value="file15">github.com/kdimtriCP/gh-inspector/internal/mock/mock_github/mock_interfaces.go (0.0%)</option>
				
				<option value="file16">github.com/kdimtriCP/gh-inspector/internal/mock/mock_scoring/mock_scorer.go (0.0%)</option>
				
				<option value="file17">github.com/kdimtriCP/gh-inspector/internal/scoring/config.go (100.0%)</option>
				
				<option value="file18">github.com/kdimtriCP/gh-inspector/internal/scoring/scorer.go (100.0%)</option>
				
				<option value="file19">github.com/kdimtriCP/gh-inspector/internal/testutil/testutil.go (0.0%)</option>
				
				<option value="file20">github.com/kdimtriCP/gh-inspector/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "github.com/joho/godotenv"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var rootCmd = &amp;cobra.Command{
        Use:   "gh-inspector",
        Short: "Analyze GitHub repositories",
        Long:  `A CLI tool for scoring GitHub repositories.`,
}

func Execute() <span class="cov0" title="0">{
        cobra.CheckErr(rootCmd.Execute())
}</span>

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig)
        rootCmd.PersistentFlags().String("config", "", "config file (default is ./configs/config.yaml)")
        _ = viper.BindPFlag("config", rootCmd.PersistentFlags().Lookup("config"))
}</span>

func initConfig() <span class="cov0" title="0">{
        viper.SetConfigType("yaml")
        viper.SetConfigName("config")
        viper.AddConfigPath("./configs")
        _ = godotenv.Load(".env")
        viper.AutomaticEnv()

        _ = viper.ReadInConfig()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "context"
        "fmt"
        "os"
        "time"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"

        "github.com/kdimtriCP/gh-inspector/internal/cache"
        "github.com/kdimtriCP/gh-inspector/internal/formatter"
        "github.com/kdimtriCP/gh-inspector/internal/github"
        "github.com/kdimtriCP/gh-inspector/internal/metrics"
        "github.com/kdimtriCP/gh-inspector/internal/scoring"
)

var (
        repos        []string
        outputFormat string
        noCache      bool
)

var scoreCmd = &amp;cobra.Command{
        Use:   "score",
        Short: "Score GitHub repositories",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(repos) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no repositories specified")
                }</span>

                <span class="cov0" title="0">token := viper.GetString("github_token")
                if token == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("GitHub token not configured")
                }</span>

                <span class="cov0" title="0">scoringConfig := &amp;scoring.Config{}
                _ = viper.UnmarshalKey("scoring", scoringConfig)

                analyzer := github.NewRepoAnalyzer(token, scoringConfig)
                ctx := context.Background()

                if viper.GetBool("cache.enabled") &amp;&amp; !noCache </span><span class="cov0" title="0">{
                        cacheDir := viper.GetString("cache.directory")
                        c, err := cache.New(cacheDir)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Warning: failed to initialize cache: %v\n", err)
                        }</span> else<span class="cov0" title="0"> {
                                analyzer.SetCache(c)
                                defer c.Close()

                                cacheTTL := viper.GetInt("cache.ttl")
                                if cacheTTL &gt; 0 </span><span class="cov0" title="0">{
                                        ttlDuration := time.Duration(cacheTTL) * time.Second
                                        analyzer.SetCacheTTL(ttlDuration)
                                }</span>
                        }
                }

                <span class="cov0" title="0">var allMetrics []*metrics.Repository

                for _, repo := range repos </span><span class="cov0" title="0">{
                        metrics, err := analyzer.Analyze(ctx, repo)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error analyzing %s: %v\n", repo, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">allMetrics = append(allMetrics, metrics)</span>
                }

                <span class="cov0" title="0">if len(allMetrics) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no repositories could be analyzed")
                }</span>

                <span class="cov0" title="0">format := outputFormat
                if format == "" </span><span class="cov0" title="0">{
                        format = viper.GetString("output_format")
                }</span>
                <span class="cov0" title="0">if format == "" </span><span class="cov0" title="0">{
                        format = formatter.FormatTable
                }</span>

                <span class="cov0" title="0">formatter, err := formatter.New(format)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return formatter.Format(os.Stdout, allMetrics)</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(scoreCmd)
        scoreCmd.Flags().StringSliceVarP(&amp;repos, "repos", "r", []string{}, "List of GitHub repositories")
        scoreCmd.Flags().StringVarP(&amp;outputFormat, "output", "o", "", "Output format (table, json, json-compact, csv)")
        scoreCmd.Flags().BoolVar(&amp;noCache, "no-cache", false, "Disable caching")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cache

import (
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "os"
        "path/filepath"
)

func New(cacheDir string) (Cache, error) <span class="cov4" title="2">{
        if cacheDir == "" </span><span class="cov1" title="1">{
                cacheDir = ".gh-inspector-cache"
        }</span>

        <span class="cov4" title="2">if err := os.MkdirAll(cacheDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cache directory: %w", err)
        }</span>

        <span class="cov4" title="2">dbPath := filepath.Join(cacheDir, "cache.db")
        return NewSQLiteCache(dbPath)</span>
}

func GenerateKey(parts ...string) string <span class="cov10" title="6">{
        h := sha256.New()
        for _, part := range parts </span><span class="cov10" title="6">{
                h.Write([]byte(part))
        }</span>
        <span class="cov10" title="6">return hex.EncodeToString(h.Sum(nil))</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cache

import (
        "database/sql"
        "fmt"
        "path/filepath"
        "time"

        _ "github.com/mattn/go-sqlite3"
)

type SQLiteCache struct {
        db *sql.DB
}

func NewSQLiteCache(dbPath string) (*SQLiteCache, error) <span class="cov6" title="3">{
        if dbPath == "" </span><span class="cov0" title="0">{
                dbPath = filepath.Join(".gh-inspector", "cache.db")
        }</span>

        <span class="cov6" title="3">db, err := sql.Open("sqlite3", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov6" title="3">cache := &amp;SQLiteCache{db: db}
        if err := cache.createTable(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to create table: %w", err)
        }</span>

        <span class="cov6" title="3">go cache.cleanupExpired()

        return cache, nil</span>
}

func (c *SQLiteCache) createTable() error <span class="cov6" title="3">{
        query := `
        CREATE TABLE IF NOT EXISTS cache (
                key TEXT PRIMARY KEY,
                value BLOB NOT NULL,
                expires_at INTEGER NOT NULL,
                created_at INTEGER NOT NULL
        );
        CREATE INDEX IF NOT EXISTS idx_expires_at ON cache(expires_at);
        `
        _, err := c.db.Exec(query)
        return err
}</span>

func (c *SQLiteCache) Get(key string) ([]byte, bool, error) <span class="cov10" title="6">{
        var value []byte
        var expiresAt int64

        query := "SELECT value, expires_at FROM cache WHERE key = ?"
        err := c.db.QueryRow(query, key).Scan(&amp;value, &amp;expiresAt)
        if err == sql.ErrNoRows </span><span class="cov9" title="5">{
                return nil, false, nil
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, false, fmt.Errorf("failed to get cache entry: %w", err)
        }</span>

        <span class="cov1" title="1">if time.Now().Unix() &gt; expiresAt </span><span class="cov0" title="0">{
                _ = c.Delete(key)
                return nil, false, nil
        }</span>

        <span class="cov1" title="1">return value, true, nil</span>
}

func (c *SQLiteCache) Set(key string, value []byte, ttl time.Duration) error <span class="cov9" title="5">{
        expiresAt := time.Now().Add(ttl).Unix()
        createdAt := time.Now().Unix()

        query := `
        INSERT OR REPLACE INTO cache (key, value, expires_at, created_at)
        VALUES (?, ?, ?, ?)
        `
        _, err := c.db.Exec(query, key, value, expiresAt, createdAt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set cache entry: %w", err)
        }</span>

        <span class="cov9" title="5">return nil</span>
}

func (c *SQLiteCache) Delete(key string) error <span class="cov1" title="1">{
        query := "DELETE FROM cache WHERE key = ?"
        _, err := c.db.Exec(query, key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete cache entry: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (c *SQLiteCache) Clear() error <span class="cov1" title="1">{
        query := "DELETE FROM cache"
        _, err := c.db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear cache: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (c *SQLiteCache) Close() error <span class="cov6" title="3">{
        return c.db.Close()
}</span>

func (c *SQLiteCache) cleanupExpired() <span class="cov6" title="3">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                query := "DELETE FROM cache WHERE expires_at &lt; ?"
                _, _ = c.db.Exec(query, time.Now().Unix())
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package formatter

import (
        "encoding/csv"
        "fmt"
        "io"

        "github.com/kdimtriCP/gh-inspector/internal/metrics"
)

type CSVFormatter struct{}

func NewCSVFormatter() *CSVFormatter <span class="cov8" title="1">{
        return &amp;CSVFormatter{}
}</span>

func (f *CSVFormatter) Format(writer io.Writer, metricsData []*metrics.Repository) error <span class="cov8" title="1">{
        w := csv.NewWriter(writer)
        defer w.Flush()

        headers := GetRecordHeaders()
        if err := w.Write(headers); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, m := range metricsData </span><span class="cov8" title="1">{
                record := MetricsToRecord(m)
                row := []string{
                        record.Repository,
                        fmt.Sprintf("%.1f", record.Score),
                        fmt.Sprintf("%d", record.Stars),
                        fmt.Sprintf("%d", record.Forks),
                        fmt.Sprintf("%d", record.OpenIssues),
                        fmt.Sprintf("%d", record.OpenPRs),
                        record.LastCommit,
                        record.Language,
                        record.CICD,
                        record.License,
                        record.Description,
                        record.Archived,
                }
                if err := w.Write(row); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package formatter

import (
        "fmt"
        "strings"
)

func New(format string) (Formatter, error) <span class="cov10" title="6">{
        switch strings.ToLower(format) </span>{
        case FormatTable:<span class="cov1" title="1">
                return NewTableFormatter(), nil</span>
        case FormatJSON:<span class="cov1" title="1">
                return NewJSONFormatter(true), nil</span>
        case FormatJSONCompact:<span class="cov1" title="1">
                return NewJSONFormatter(false), nil</span>
        case FormatCSV:<span class="cov1" title="1">
                return NewCSVFormatter(), nil</span>
        default:<span class="cov4" title="2">
                return nil, fmt.Errorf("unsupported format: %s", format)</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package formatter

import (
        "encoding/json"
        "io"

        "github.com/kdimtriCP/gh-inspector/internal/metrics"
)

type JSONFormatter struct {
        indent bool
}

func NewJSONFormatter(indent bool) *JSONFormatter <span class="cov10" title="2">{
        return &amp;JSONFormatter{indent: indent}
}</span>

func (f *JSONFormatter) Format(writer io.Writer, metricsData []*metrics.Repository) error <span class="cov10" title="2">{
        var records []*Record
        for _, m := range metricsData </span><span class="cov10" title="2">{
                records = append(records, MetricsToRecord(m))
        }</span>

        <span class="cov10" title="2">encoder := json.NewEncoder(writer)
        if f.indent </span><span class="cov1" title="1">{
                encoder.SetIndent("", "  ")
        }</span>
        <span class="cov10" title="2">return encoder.Encode(records)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package formatter

import (
        "io"

        "github.com/kdimtriCP/gh-inspector/internal/metrics"
        "github.com/olekukonko/tablewriter"
)

type TableFormatter struct{}

func NewTableFormatter() *TableFormatter <span class="cov1" title="1">{
        return &amp;TableFormatter{}
}</span>

func (f *TableFormatter) Format(writer io.Writer, metricsData []*metrics.Repository) error <span class="cov1" title="1">{
        table := tablewriter.NewWriter(writer)
        table.SetHeader(GetRecordHeaders())

        table.SetBorder(false)
        table.SetCenterSeparator("")
        table.SetColumnSeparator("")
        table.SetRowSeparator("")
        table.SetHeaderAlignment(tablewriter.ALIGN_LEFT)
        table.SetAlignment(tablewriter.ALIGN_LEFT)

        for _, m := range metricsData </span><span class="cov10" title="2">{
                raw := MetricsToRecord(m).Strings()
                table.Append(raw)
        }</span>

        <span class="cov1" title="1">table.Render()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package formatter

import (
        "fmt"
        "reflect"
        "time"

        "github.com/kdimtriCP/gh-inspector/internal/metrics"
)

const (
        FormatTable       = "table"
        FormatJSON        = "json"
        FormatJSONCompact = "json-compact"
        FormatCSV         = "csv"
)

type Record struct {
        Repository  string  `json:"repository"`
        Score       float64 `json:"score"`
        Stars       int     `json:"stars"`
        Forks       int     `json:"forks"`
        OpenIssues  int     `json:"open_issues"`
        OpenPRs     int     `json:"open_prs"`
        LastCommit  string  `json:"last_commit"`
        Language    string  `json:"language"`
        CICD        string  `json:"ci_cd"`
        License     string  `json:"license"`
        Description string  `json:"description"`
        Archived    string  `json:"archived"`
}

func MetricsToRecord(m *metrics.Repository) *Record <span class="cov5" title="5">{
        lastCommit := "N/A"
        if !m.LastCommitDate.IsZero() </span><span class="cov2" title="2">{
                daysAgo := int(time.Since(m.LastCommitDate).Hours() / 24)
                lastCommit = fmt.Sprintf("%d days ago", daysAgo)
        }</span>

        <span class="cov5" title="5">cicd := "No"
        if m.HasCICD </span><span class="cov2" title="2">{
                cicd = "Yes"
        }</span>

        <span class="cov5" title="5">license := "No"
        if m.HasLicense </span><span class="cov4" title="4">{
                license = "Yes"
        }</span>

        <span class="cov5" title="5">lang := m.PrimaryLanguage
        if lang == "" </span><span class="cov4" title="3">{
                lang = "N/A"
        }</span>

        <span class="cov5" title="5">archived := "No"
        if m.IsArchived </span><span class="cov1" title="1">{
                archived = "Yes"
        }</span>

        <span class="cov5" title="5">return &amp;Record{
                Repository:  fmt.Sprintf("%s/%s", m.Owner, m.Name),
                Score:       m.Score,
                Stars:       m.Stars,
                Forks:       m.Forks,
                OpenIssues:  m.OpenIssues,
                OpenPRs:     m.OpenPRs,
                LastCommit:  lastCommit,
                Language:    lang,
                CICD:        cicd,
                License:     license,
                Description: m.Description,
                Archived:    archived,
        }</span>
}

func (r *Record) String() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "Repository: %s, Score: %.1f, Stars: %d, Forks: %d, Open Issues: %d, Open PRs: %d, Last Commit: %s, Language: %s, CI/CD: %s, License: %s, Description: %s, Archived: %s",
                r.Repository,
                r.Score,
                r.Stars,
                r.Forks,
                r.OpenIssues,
                r.OpenPRs,
                r.LastCommit,
                r.Language,
                r.CICD,
                r.License,
                r.Description,
                r.Archived,
        )
}</span>

func (r *Record) Strings() []string <span class="cov2" title="2">{
        return []string{
                r.Repository,
                fmt.Sprintf("%.1f", r.Score),
                fmt.Sprintf("%d", r.Stars),
                fmt.Sprintf("%d", r.Forks),
                fmt.Sprintf("%d", r.OpenIssues),
                fmt.Sprintf("%d", r.OpenPRs),
                r.LastCommit,
                r.Language,
                r.CICD,
                r.License,
                r.Description,
                r.Archived,
        }
}</span>

func GetRecordHeaders() []string <span class="cov2" title="2">{
        record := Record{}
        t := reflect.TypeOf(record)
        headers := make([]string, 0, t.NumField())

        for i := 0; i &lt; t.NumField(); i++ </span><span class="cov10" title="24">{
                field := t.Field(i)
                jsonTag := field.Tag.Get("json")
                if jsonTag != "" &amp;&amp; jsonTag != "-" </span><span class="cov10" title="24">{
                        headers = append(headers, jsonTag)
                }</span>
        }

        <span class="cov2" title="2">return headers</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package github

import (
        "context"
        "fmt"
        "time"

        "github.com/kdimtriCP/gh-inspector/internal/cache"
        "github.com/kdimtriCP/gh-inspector/internal/metrics"
        "github.com/kdimtriCP/gh-inspector/internal/scoring"
)

type RepoAnalyzer struct {
        client *Client
        scorer *scoring.Scorer
}

func NewRepoAnalyzer(token string, scoringConfig *scoring.Config) *RepoAnalyzer <span class="cov0" title="0">{
        return &amp;RepoAnalyzer{
                client: NewClient(token),
                scorer: scoring.NewScorer(scoringConfig),
        }
}</span>

func (ra *RepoAnalyzer) SetCache(c cache.Cache) <span class="cov0" title="0">{
        ra.client.SetCache(c)
}</span>

func (ra *RepoAnalyzer) SetCacheTTL(ttl time.Duration) <span class="cov0" title="0">{
        ra.client.SetCacheTTL(ttl)
}</span>

func (ra *RepoAnalyzer) Analyze(ctx context.Context, repo string) (*metrics.Repository, error) <span class="cov0" title="0">{
        metrics, err := ra.client.CollectBasicMetrics(ctx, repo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to collect metrics for %s: %w", repo, err)
        }</span>

        <span class="cov0" title="0">metrics.Score = ra.scorer.Score(metrics)

        return metrics, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package github

import (
        "context"
        "time"

        "github.com/kdimtriCP/gh-inspector/internal/cache"
        "github.com/shurcooL/githubv4"
        "golang.org/x/oauth2"
)

type Client struct {
        graphqlClient *githubv4.Client
        cache         cache.Cache
        cacheTTL      time.Duration
}

func NewClient(token string) *Client <span class="cov10" title="3">{
        src := oauth2.StaticTokenSource(
                &amp;oauth2.Token{AccessToken: token},
        )
        httpClient := oauth2.NewClient(context.Background(), src)

        return &amp;Client{
                graphqlClient: githubv4.NewClient(httpClient),
                cacheTTL:      1 * time.Hour,
        }
}</span>

func (c *Client) SetCache(cache cache.Cache) <span class="cov1" title="1">{
        c.cache = cache
}</span>

func (c *Client) SetCacheTTL(ttl time.Duration) <span class="cov1" title="1">{
        c.cacheTTL = ttl
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package github

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/kdimtriCP/gh-inspector/internal/cache"
        "github.com/kdimtriCP/gh-inspector/internal/metrics"
        "github.com/shurcooL/githubv4"
)

func (c *Client) CollectBasicMetrics(ctx context.Context, repoFullName string) (*metrics.Repository, error) <span class="cov0" title="0">{
        if c.cache != nil </span><span class="cov0" title="0">{
                cacheKey := cache.GenerateKey("repo", repoFullName)
                if data, found, err := c.cache.Get(cacheKey); err == nil &amp;&amp; found </span><span class="cov0" title="0">{
                        var result metrics.Repository
                        if err := json.Unmarshal(data, &amp;result); err == nil </span><span class="cov0" title="0">{
                                return &amp;result, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">parts := strings.Split(repoFullName, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid repository format, expected owner/name")
        }</span>
        <span class="cov0" title="0">owner, name := parts[0], parts[1]

        var query metrics.RepositoryQuery
        variables := map[string]interface{}{
                metrics.VarOwner: githubv4.String(owner),
                metrics.VarName:  githubv4.String(name),
        }

        err := c.graphqlClient.Query(ctx, &amp;query, variables)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch repository data: %w", err)
        }</span>

        <span class="cov0" title="0">repo := query.Repository
        result := &amp;metrics.Repository{
                Owner:       string(repo.Owner.Login),
                Name:        string(repo.Name),
                Stars:       int(repo.StargazerCount),
                Forks:       int(repo.ForkCount),
                OpenIssues:  int(repo.Issues.TotalCount),
                OpenPRs:     int(repo.PullRequests.TotalCount),
                Description: string(repo.Description),
                IsArchived:  bool(repo.IsArchived),
                HasLicense:  repo.LicenseInfo != nil,
        }

        if repo.PrimaryLanguage != nil </span><span class="cov0" title="0">{
                result.PrimaryLanguage = string(repo.PrimaryLanguage.Name)
        }</span>

        <span class="cov0" title="0">if repo.DefaultBranchRef != nil &amp;&amp; len(repo.DefaultBranchRef.Target.Commit.History.Edges) &gt; 0 </span><span class="cov0" title="0">{
                result.LastCommitDate = repo.DefaultBranchRef.Target.Commit.History.Edges[0].Node.CommittedDate.Time
        }</span>

        <span class="cov0" title="0">for _, entry := range repo.Object.Tree.Entries </span><span class="cov0" title="0">{
                entryLower := strings.ToLower(string(entry.Name))
                if strings.HasPrefix(entryLower, metrics.CIGitHub) ||
                        strings.HasPrefix(entryLower, metrics.CIGitLab) ||
                        strings.HasPrefix(entryLower, metrics.CICircleCI) ||
                        entryLower == metrics.CITravis ||
                        entryLower == metrics.CIJenkins </span><span class="cov0" title="0">{
                        result.HasCICD = true
                }</span>
                <span class="cov0" title="0">if entryLower == metrics.FileContributing || entryLower == metrics.FileContributingAlt </span><span class="cov0" title="0">{
                        result.HasContributing = true
                }</span>
        }

        <span class="cov0" title="0">if c.cache != nil </span><span class="cov0" title="0">{
                cacheKey := cache.GenerateKey("repo", repoFullName)
                if data, err := json.Marshal(result); err == nil </span><span class="cov0" title="0">{
                        _ = c.cache.Set(cacheKey, data, c.cacheTTL)
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package metrics

import "time"

type Repository struct {
        Owner           string
        Name            string
        Stars           int
        Forks           int
        OpenIssues      int
        OpenPRs         int
        LastCommitDate  time.Time
        Description     string
        PrimaryLanguage string
        IsArchived      bool
        HasCICD         bool
        HasLicense      bool
        HasContributing bool
        Score           float64
}

func (m *Repository) GetStars() int                <span class="cov1" title="1">{ return m.Stars }</span>
func (m *Repository) GetForks() int                <span class="cov1" title="1">{ return m.Forks }</span>
func (m *Repository) GetOpenIssues() int           <span class="cov1" title="1">{ return m.OpenIssues }</span>
func (m *Repository) GetOpenPRs() int              <span class="cov1" title="1">{ return m.OpenPRs }</span>
func (m *Repository) GetLastCommitDate() time.Time <span class="cov1" title="1">{ return m.LastCommitDate }</span>
func (m *Repository) GetIsArchived() bool          <span class="cov1" title="1">{ return m.IsArchived }</span>
func (m *Repository) GetHasLicense() bool          <span class="cov1" title="1">{ return m.HasLicense }</span>
func (m *Repository) GetHasCICD() bool             <span class="cov1" title="1">{ return m.HasCICD }</span>
func (m *Repository) GetHasContributing() bool     <span class="cov1" title="1">{ return m.HasContributing }</span>

func (m *Repository) DaysSinceLastCommit() int <span class="cov10" title="5">{
        if m.LastCommitDate.IsZero() </span><span class="cov1" title="1">{
                return -1
        }</span>
        <span class="cov8" title="4">return int(time.Since(m.LastCommitDate).Hours() / 24)</span>
}

func (m *Repository) FullName() string <span class="cov8" title="4">{
        return m.Owner + "/" + m.Name
}</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: types.go

// Package mock_cache is a generated GoMock package.
package mock_cache

import (
        reflect "reflect"
        time "time"

        gomock "github.com/golang/mock/gomock"
)

// MockCache is a mock of Cache interface.
type MockCache struct {
        ctrl     *gomock.Controller
        recorder *MockCacheMockRecorder
}

// MockCacheMockRecorder is the mock recorder for MockCache.
type MockCacheMockRecorder struct {
        mock *MockCache
}

// NewMockCache creates a new mock instance.
func NewMockCache(ctrl *gomock.Controller) *MockCache <span class="cov0" title="0">{
        mock := &amp;MockCache{ctrl: ctrl}
        mock.recorder = &amp;MockCacheMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCache) EXPECT() *MockCacheMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Clear mocks base method.
func (m *MockCache) Clear() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Clear")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Clear indicates an expected call of Clear.
func (mr *MockCacheMockRecorder) Clear() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Clear", reflect.TypeOf((*MockCache)(nil).Clear))
}</span>

// Close mocks base method.
func (m *MockCache) Close() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockCacheMockRecorder) Close() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockCache)(nil).Close))
}</span>

// Delete mocks base method.
func (m *MockCache) Delete(key string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", key)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockCacheMockRecorder) Delete(key interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCache)(nil).Delete), key)
}</span>

// Get mocks base method.
func (m *MockCache) Get(key string) ([]byte, bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", key)
        ret0, _ := ret[0].([]byte)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// Get indicates an expected call of Get.
func (mr *MockCacheMockRecorder) Get(key interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCache)(nil).Get), key)
}</span>

// Set mocks base method.
func (m *MockCache) Set(key string, value []byte, ttl time.Duration) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Set", key, value, ttl)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Set indicates an expected call of Set.
func (mr *MockCacheMockRecorder) Set(key, value, ttl interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockCache)(nil).Set), key, value, ttl)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: formatter.go

// Package mock_formatter is a generated GoMock package.
package mock_formatter

import (
        io "io"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        metrics "github.com/kdimtriCP/gh-inspector/internal/metrics"
)

// MockFormatter is a mock of Formatter interface.
type MockFormatter struct {
        ctrl     *gomock.Controller
        recorder *MockFormatterMockRecorder
}

// MockFormatterMockRecorder is the mock recorder for MockFormatter.
type MockFormatterMockRecorder struct {
        mock *MockFormatter
}

// NewMockFormatter creates a new mock instance.
func NewMockFormatter(ctrl *gomock.Controller) *MockFormatter <span class="cov0" title="0">{
        mock := &amp;MockFormatter{ctrl: ctrl}
        mock.recorder = &amp;MockFormatterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFormatter) EXPECT() *MockFormatterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Format mocks base method.
func (m *MockFormatter) Format(writer io.Writer, metrics []*metrics.Repository) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Format", writer, metrics)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Format indicates an expected call of Format.
func (mr *MockFormatterMockRecorder) Format(writer, metrics interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Format", reflect.TypeOf((*MockFormatter)(nil).Format), writer, metrics)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: interfaces.go

// Package mock_github is a generated GoMock package.
package mock_github

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        metrics "github.com/kdimtriCP/gh-inspector/internal/metrics"
)

// MockMetricsCollector is a mock of MetricsCollector interface.
type MockMetricsCollector struct {
        ctrl     *gomock.Controller
        recorder *MockMetricsCollectorMockRecorder
}

// MockMetricsCollectorMockRecorder is the mock recorder for MockMetricsCollector.
type MockMetricsCollectorMockRecorder struct {
        mock *MockMetricsCollector
}

// NewMockMetricsCollector creates a new mock instance.
func NewMockMetricsCollector(ctrl *gomock.Controller) *MockMetricsCollector <span class="cov0" title="0">{
        mock := &amp;MockMetricsCollector{ctrl: ctrl}
        mock.recorder = &amp;MockMetricsCollectorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMetricsCollector) EXPECT() *MockMetricsCollectorMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CollectBasicMetrics mocks base method.
func (m *MockMetricsCollector) CollectBasicMetrics(ctx context.Context, repoFullName string) (*metrics.Repository, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CollectBasicMetrics", ctx, repoFullName)
        ret0, _ := ret[0].(*metrics.Repository)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CollectBasicMetrics indicates an expected call of CollectBasicMetrics.
func (mr *MockMetricsCollectorMockRecorder) CollectBasicMetrics(ctx, repoFullName interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CollectBasicMetrics", reflect.TypeOf((*MockMetricsCollector)(nil).CollectBasicMetrics), ctx, repoFullName)
}</span>

// MockAnalyzer is a mock of Analyzer interface.
type MockAnalyzer struct {
        ctrl     *gomock.Controller
        recorder *MockAnalyzerMockRecorder
}

// MockAnalyzerMockRecorder is the mock recorder for MockAnalyzer.
type MockAnalyzerMockRecorder struct {
        mock *MockAnalyzer
}

// NewMockAnalyzer creates a new mock instance.
func NewMockAnalyzer(ctrl *gomock.Controller) *MockAnalyzer <span class="cov0" title="0">{
        mock := &amp;MockAnalyzer{ctrl: ctrl}
        mock.recorder = &amp;MockAnalyzerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAnalyzer) EXPECT() *MockAnalyzerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Analyze mocks base method.
func (m *MockAnalyzer) Analyze(ctx context.Context, repo string) (*metrics.Repository, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Analyze", ctx, repo)
        ret0, _ := ret[0].(*metrics.Repository)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Analyze indicates an expected call of Analyze.
func (mr *MockAnalyzerMockRecorder) Analyze(ctx, repo interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Analyze", reflect.TypeOf((*MockAnalyzer)(nil).Analyze), ctx, repo)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: scorer.go

// Package mock_scoring is a generated GoMock package.
package mock_scoring

import (
        reflect "reflect"
        time "time"

        gomock "github.com/golang/mock/gomock"
)

// MockRepositoryMetrics is a mock of RepositoryMetrics interface.
type MockRepositoryMetrics struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMetricsMockRecorder
}

// MockRepositoryMetricsMockRecorder is the mock recorder for MockRepositoryMetrics.
type MockRepositoryMetricsMockRecorder struct {
        mock *MockRepositoryMetrics
}

// NewMockRepositoryMetrics creates a new mock instance.
func NewMockRepositoryMetrics(ctrl *gomock.Controller) *MockRepositoryMetrics <span class="cov0" title="0">{
        mock := &amp;MockRepositoryMetrics{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMetricsMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepositoryMetrics) EXPECT() *MockRepositoryMetricsMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetForks mocks base method.
func (m *MockRepositoryMetrics) GetForks() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetForks")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// GetForks indicates an expected call of GetForks.
func (mr *MockRepositoryMetricsMockRecorder) GetForks() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetForks", reflect.TypeOf((*MockRepositoryMetrics)(nil).GetForks))
}</span>

// GetHasCICD mocks base method.
func (m *MockRepositoryMetrics) GetHasCICD() bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetHasCICD")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// GetHasCICD indicates an expected call of GetHasCICD.
func (mr *MockRepositoryMetricsMockRecorder) GetHasCICD() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetHasCICD", reflect.TypeOf((*MockRepositoryMetrics)(nil).GetHasCICD))
}</span>

// GetHasContributing mocks base method.
func (m *MockRepositoryMetrics) GetHasContributing() bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetHasContributing")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// GetHasContributing indicates an expected call of GetHasContributing.
func (mr *MockRepositoryMetricsMockRecorder) GetHasContributing() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetHasContributing", reflect.TypeOf((*MockRepositoryMetrics)(nil).GetHasContributing))
}</span>

// GetHasLicense mocks base method.
func (m *MockRepositoryMetrics) GetHasLicense() bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetHasLicense")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// GetHasLicense indicates an expected call of GetHasLicense.
func (mr *MockRepositoryMetricsMockRecorder) GetHasLicense() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetHasLicense", reflect.TypeOf((*MockRepositoryMetrics)(nil).GetHasLicense))
}</span>

// GetIsArchived mocks base method.
func (m *MockRepositoryMetrics) GetIsArchived() bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetIsArchived")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// GetIsArchived indicates an expected call of GetIsArchived.
func (mr *MockRepositoryMetricsMockRecorder) GetIsArchived() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetIsArchived", reflect.TypeOf((*MockRepositoryMetrics)(nil).GetIsArchived))
}</span>

// GetLastCommitDate mocks base method.
func (m *MockRepositoryMetrics) GetLastCommitDate() time.Time <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetLastCommitDate")
        ret0, _ := ret[0].(time.Time)
        return ret0
}</span>

// GetLastCommitDate indicates an expected call of GetLastCommitDate.
func (mr *MockRepositoryMetricsMockRecorder) GetLastCommitDate() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLastCommitDate", reflect.TypeOf((*MockRepositoryMetrics)(nil).GetLastCommitDate))
}</span>

// GetOpenIssues mocks base method.
func (m *MockRepositoryMetrics) GetOpenIssues() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetOpenIssues")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// GetOpenIssues indicates an expected call of GetOpenIssues.
func (mr *MockRepositoryMetricsMockRecorder) GetOpenIssues() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOpenIssues", reflect.TypeOf((*MockRepositoryMetrics)(nil).GetOpenIssues))
}</span>

// GetOpenPRs mocks base method.
func (m *MockRepositoryMetrics) GetOpenPRs() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetOpenPRs")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// GetOpenPRs indicates an expected call of GetOpenPRs.
func (mr *MockRepositoryMetricsMockRecorder) GetOpenPRs() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOpenPRs", reflect.TypeOf((*MockRepositoryMetrics)(nil).GetOpenPRs))
}</span>

// GetStars mocks base method.
func (m *MockRepositoryMetrics) GetStars() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetStars")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// GetStars indicates an expected call of GetStars.
func (mr *MockRepositoryMetricsMockRecorder) GetStars() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStars", reflect.TypeOf((*MockRepositoryMetrics)(nil).GetStars))
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package scoring

type Config struct {
        Weights Weights `yaml:"weights"`
}

type Weights struct {
        Stars           float64 `yaml:"stars"`
        Forks           float64 `yaml:"forks"`
        RecentActivity  float64 `yaml:"recent_activity"`
        OpenIssues      float64 `yaml:"open_issues"`
        OpenPRs         float64 `yaml:"open_prs"`
        HasLicense      float64 `yaml:"has_license"`
        HasCICD         float64 `yaml:"has_cicd"`
        HasContributing float64 `yaml:"has_contributing"`
}

func DefaultConfig() *Config <span class="cov10" title="5">{
        return &amp;Config{
                Weights: Weights{
                        Stars:           0.30,
                        Forks:           0.15,
                        RecentActivity:  0.25,
                        OpenIssues:      0.10,
                        OpenPRs:         0.05,
                        HasLicense:      0.05,
                        HasCICD:         0.05,
                        HasContributing: 0.05,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package scoring

import (
        "math"
        "time"
)

//go:generate mockgen -source=$GOFILE -destination=../mock/mock_scoring/mock_$GOFILE -package=mock_scoring

type RepositoryMetrics interface {
        GetStars() int
        GetForks() int
        GetOpenIssues() int
        GetOpenPRs() int
        GetLastCommitDate() time.Time
        GetIsArchived() bool
        GetHasLicense() bool
        GetHasCICD() bool
        GetHasContributing() bool
}

type Scorer struct {
        config *Config
}

func NewScorer(config *Config) *Scorer <span class="cov7" title="6">{
        if config == nil </span><span class="cov1" title="1">{
                config = DefaultConfig()
        }</span>
        <span class="cov7" title="6">return &amp;Scorer{config: config}</span>
}

func (s *Scorer) Score(metrics RepositoryMetrics) float64 <span class="cov6" title="4">{
        if metrics.GetIsArchived() </span><span class="cov1" title="1">{
                return 0.0
        }</span>

        <span class="cov5" title="3">weights := s.config.Weights
        score := 0.0

        starsScore := math.Min(math.Log10(float64(metrics.GetStars()+1))/4.0, 1.0)
        score += starsScore * weights.Stars

        forksScore := math.Min(math.Log10(float64(metrics.GetForks()+1))/3.0, 1.0)
        score += forksScore * weights.Forks

        activityScore := s.calculateActivityScore(metrics.GetLastCommitDate())
        score += activityScore * weights.RecentActivity

        issuesScore := s.calculateIssuesScore(metrics.GetOpenIssues())
        score += issuesScore * weights.OpenIssues

        prsScore := s.calculatePRsScore(metrics.GetOpenPRs())
        score += prsScore * weights.OpenPRs

        if metrics.GetHasLicense() </span><span class="cov3" title="2">{
                score += weights.HasLicense
        }</span>
        <span class="cov5" title="3">if metrics.GetHasCICD() </span><span class="cov3" title="2">{
                score += weights.HasCICD
        }</span>
        <span class="cov5" title="3">if metrics.GetHasContributing() </span><span class="cov1" title="1">{
                score += weights.HasContributing
        }</span>

        // Normalize to 0-100 scale
        <span class="cov5" title="3">return math.Min(score*100, 100)</span>
}

func (s *Scorer) calculateActivityScore(lastCommitDate time.Time) float64 <span class="cov10" title="11">{
        if lastCommitDate.IsZero() </span><span class="cov1" title="1">{
                return 0.0
        }</span>

        <span class="cov9" title="10">daysSinceCommit := time.Since(lastCommitDate).Hours() / 24

        switch </span>{
        case daysSinceCommit &lt;= 7:<span class="cov5" title="3">
                return 1.0</span>
        case daysSinceCommit &lt;= 30:<span class="cov1" title="1">
                return 0.8</span>
        case daysSinceCommit &lt;= 90:<span class="cov3" title="2">
                return 0.6</span>
        case daysSinceCommit &lt;= 180:<span class="cov1" title="1">
                return 0.4</span>
        case daysSinceCommit &lt;= 365:<span class="cov1" title="1">
                return 0.2</span>
        default:<span class="cov3" title="2">
                return 0.0</span>
        }
}

func (s *Scorer) calculateIssuesScore(openIssues int) float64 <span class="cov9" title="10">{
        switch </span>{
        case openIssues == 0:<span class="cov3" title="2">
                return 1.0</span>
        case openIssues &lt;= 5:<span class="cov1" title="1">
                return 0.9</span>
        case openIssues &lt;= 10:<span class="cov3" title="2">
                return 0.7</span>
        case openIssues &lt;= 25:<span class="cov1" title="1">
                return 0.5</span>
        case openIssues &lt;= 50:<span class="cov3" title="2">
                return 0.3</span>
        case openIssues &lt;= 100:<span class="cov1" title="1">
                return 0.1</span>
        default:<span class="cov1" title="1">
                return 0.0</span>
        }
}

func (s *Scorer) calculatePRsScore(openPRs int) float64 <span class="cov9" title="9">{
        switch </span>{
        case openPRs == 0:<span class="cov3" title="2">
                return 1.0</span>
        case openPRs &lt;= 3:<span class="cov1" title="1">
                return 0.8</span>
        case openPRs &lt;= 5:<span class="cov3" title="2">
                return 0.6</span>
        case openPRs &lt;= 10:<span class="cov1" title="1">
                return 0.4</span>
        case openPRs &lt;= 20:<span class="cov3" title="2">
                return 0.2</span>
        default:<span class="cov1" title="1">
                return 0.0</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package testutil

import (
        "os"
        "path/filepath"
        "testing"
)

func CreateTestConfig(t *testing.T) string <span class="cov0" title="0">{
        t.Helper()
        
        configContent := `github_token: "test-token"
output_format: "table"
cache:
  enabled: true
  ttl: 3600
  directory: ""

scoring:
  weights:
    stars: 0.30
    forks: 0.15
    recent_activity: 0.25
    open_issues: 0.10
    open_prs: 0.05
    has_license: 0.05
    has_cicd: 0.05
    has_contributing: 0.05
`
        
        tempDir := t.TempDir()
        configPath := filepath.Join(tempDir, "config.yaml")
        
        err := os.WriteFile(configPath, []byte(configContent), 0644)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test config: %v", err)
        }</span>
        
        <span class="cov0" title="0">return configPath</span>
}

func SetEnv(t *testing.T, key, value string) <span class="cov0" title="0">{
        t.Helper()
        
        oldValue := os.Getenv(key)
        err := os.Setenv(key, value)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to set env var %s: %v", key, err)
        }</span>
        
        <span class="cov0" title="0">t.Cleanup(func() </span><span class="cov0" title="0">{
                os.Setenv(key, oldValue)
        }</span>)
}</pre>
		
		<pre class="file" id="file20" style="display: none">package main

import "github.com/kdimtriCP/gh-inspector/cmd"

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
